{"version":3,"sources":["../src/__prologue__.js","../src/__epilogue__.js","../src/distributedEvaluation.js"],"names":["__init__","base","Sermat","capataz","inveniemus","raiseIf","exports","__package__","__name__","__dependencies__","distributeEvaluation","args","server","Object","assign","problemDependencies","fun","keepRunning","mh","problemBuilder","Array","isArray","_checkArgs","problem","apply","map","require","__serveRequireModule__","__serveNodeModule__","Element","prototype","evaluate","element","this","schedule","info","emblem","imports","ser","mode","CIRCULAR_MODE","then","evaluation","isNaN","evaluateFunction","events","on","evalStat","statistics","stat","key","step","best","state","logger","minimum","average","maximum","standardDeviation","end","setTimeout","process","exit","run","error"],"mappings":";;4WAEA,SAASA,EAASC,EAAMC,EAAQC,EAASC,GAAa,aAGrD,IAAIC,EAAUJ,EAAKI,QAGfC,GACHC,YAAa,qBACbC,SAAU,qBACVR,SAAUA,EACVS,kBAAmBR,EAAMC,EAAQC,EAASC,ICV3C,ODYAE,EAAQH,QAAUA,EAClBG,EAAQF,WAAaA,EEPtBE,EAAQI,qBAAuB,WAoE9B,OAAO,SAA8BC,GAEpC,IAAIC,GADJD,EAhDD,SAAoBA,GAcnB,OAbAA,EAAOE,OAAOC,QACbC,uBACAC,IAAK,0EACLC,aAAa,GACXN,GAEHN,EAA+B,iBAAhBM,EAAKC,OAAqB,qBAEzCP,EAA2B,iBAAZM,EAAKO,GAAiB,6BACrCb,EAAuC,mBAAxBM,EAAKQ,eAA+B,6BACnDd,GAASe,MAAMC,QAAQV,EAAKI,qBAAsB,kCAClDV,EAA4B,mBAAbM,EAAKK,KAA0C,iBAAbL,EAAKK,IACrD,+BACML,EAkCAW,CAAWX,IACAC,OACjBM,EAAKP,EAAKO,GACVK,EAAUL,EAAGK,QAGTA,IACJA,EAAUZ,EAAKQ,eAAeK,MAAM,KAAMb,EAAKI,oBAAoBU,IAAIC,UACvER,EAAGK,QAAUA,GAMdX,EAAOe,uBAAuBhB,EAAKQ,eAAgB,UAAWR,EAAKI,qBACnEH,EAAOgB,oBAAoBxB,GAI3BmB,EAAQM,QAAQC,UAAUC,SA/C3B,SAA0BpB,GACzB,IAAIC,EAASD,EAAKC,OACjBI,EAAM,iMAKSL,EAAKK,IAClB,8DAEH,OAAO,WACN,IAAIgB,EAAUC,KACd,OAAOrB,EAAOsB,UACbC,KAAMF,KAAKG,SACXC,SAAS,SAAW,aAAc,WAClC1B,MAAOT,EAAOoC,IAAIL,MAAQM,KAAMrC,EAAOsC,iBACvCxB,IAAKA,IACHyB,KAAK,SAAUC,GAGjB,OAFAV,EAAQU,WAAatB,MAAMC,QAAQqB,GAAcA,EAChDC,MAAMD,GAAc,OAASA,GACvBA,KA2B4BE,CAAiBjC,GAItDO,EAAG2B,OAAOC,GAAE,WAAa,WACxB,IAAIC,EAAW7B,EAAG8B,WAAWC,MAAOC,IAAG,aAAeC,KAAMjC,EAAGiC,OAC9DC,EAAOlC,EAAGmC,MAAM,GACjBzC,EAAO0C,OAAOnB,KAAI,qBAAuBjB,EAAGiC,KAAK,iBAAmBJ,EAASQ,UAC5E,MAAOR,EAASS,UAAU,MAAQT,EAASU,UAAU,aACrDV,EAASW,oBAAoB,MAC9B9C,EAAO0C,OAAOnB,KAAI,kBAAoBiB,EAAKhB,SAAS,OAKrD,IAAInB,IAAgBN,EAAKM,YACzB,SAAS0C,IAKR,OAJK1C,IACJL,EAAO0C,OAAOnB,KAAI,oBAClByB,WAAWC,QAAQC,KAAM,KAEnB5C,EAER,OAAOA,EAAG6C,MAAMtB,KAAK,WAEpB,OADA7B,EAAO0C,OAAOnB,KAAI,aACXwB,KACL,SAAUK,GAEZ,OADApD,EAAO0C,OAAOU,MAAMA,EAAM,IACnBL,OApHqB,GDNvBrD","file":"capataz-inveniemus.min.js","sourcesContent":["/** Library capataz-inveniemus wrapper and layout.\n*/\nfunction __init__(base, Sermat, capataz, inveniemus){ \"use strict\";\n\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar raiseIf = base.raiseIf;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'capataz-inveniemus',\n\t\t__name__: 'capataz_inveniemus',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, capataz, inveniemus]\n\t};\n\texports.capataz = capataz;\n\texports.inveniemus = inveniemus;\n\n// See __epilogue__.js\n","// See __prologue__.js\n\n\treturn exports;\n}","/** # Distributed evaluation.\n\nUsually the vast majority of the processing budget of a metaheuristic is dedicated to the evaluation\nof the objective function (e.g. fitness in evolutionary computing). Hence, it makes sence in most\ncases to set up a distributed run so that the clients execute the evaluations of candidate\nsolutions, while the server handles all the rest.\n*/\n\nexports.distributeEvaluation = (function () {\n\t/** The arguments are:\n\n\t+ `server`: A configured Capataz server,\n\n\t+ `mh`: An Inveniemus' Metaheuristic instance.\n\n\t+ `problemBuilder`: A function that builds the `Problem` instance to solve with the\n\tMetaheuristic. May require modules as arguments.\n\n\t+ `problemDependencies`: Modules required by the `problemBuilder`, that will be loaded with\n\tRequireJS. By default is `[]`.\n\n\t+ `args`: Extra arguments to consider for the evaluation. The element is always included, in\n\tthe last argument. By default is `[]`.\n\n\t+ `fun`: The job function that performs the evaluation. By default is\n\t`problem.evaluation(element)`.\n\n\t+ `keepRunning`: If `true` leaves the server running after finishing. By default is `false`.\n\t*/\n\tfunction _checkArgs(args) {\n\t\targs = Object.assign({\n\t\t\tproblemDependencies: [],\n\t\t\tfun: 'function (problem, element) {\\n\\treturn problem.evaluation(element);\\n}',\n\t\t\tkeepRunning: false\n\t\t}, args);\n\t\t//TODO Check if it is a Capataz instance.\n\t\traiseIf(typeof args.server !== 'object', 'Invalid `server`!');\n\t\t//TODO Check if it is a Metaheuristic instance.\n\t\traiseIf(typeof args.mh !== 'object', 'Invalid `metaheuristics`!');\n\t\traiseIf(typeof args.problemBuilder !== 'function', 'Invalid `problemBuilder`!');\n\t\traiseIf(!Array.isArray(args.problemDependencies), 'Invalid `problemDependencies`!');\n\t\traiseIf(typeof args.fun !== 'function' && typeof args.fun !== 'string',\n\t\t\t'Invalid `jobPrototype.fun`!');\n\t\treturn args;\n\t}\n\n\t/** Builds a new `evaluate` method for the problem's `Element` class, which schedules the job\n\tfunction in the capataz server.\n\t*/\n\tfunction evaluateFunction(args) {\n\t\tvar server = args.server,\n\t\t\tfun = 'function () {\\n'+\n\t\t\t\t'\\tvar Sermat = arguments[0],\\n'+\n\t\t\t\t'\\t\\tinveniemus = arguments[1];\\n'+\n\t\t\t\t'\\tSermat.include(base);\\n'+\n\t\t\t\t'\\targuments[arguments.length-1] = Sermat.mat(arguments[arguments.length-1]);\\n'+\n\t\t\t\t'\\treturn ('+ args.fun +\n\t\t\t\t\t').apply(this, Array.prototype.slice.call(arguments, 2));\\n'+\n\t\t\t\t'}';\n\t\treturn function scheduledEvaluate() {\n\t\t\tvar element = this;\n\t\t\treturn server.schedule({\n\t\t\t\tinfo: this.emblem(),\n\t\t\t\timports: ['sermat', 'inveniemus', 'problem'],\n\t\t\t\targs: [Sermat.ser(this, { mode: Sermat.CIRCULAR_MODE })],\n\t\t\t\tfun: fun,\n\t\t\t}).then(function (evaluation) {\n\t\t\t\telement.evaluation = Array.isArray(evaluation) ? evaluation :\n\t\t\t\t\tisNaN(evaluation) ? null : [+evaluation];\n\t\t\t\treturn evaluation;\n\t\t\t});\n\t\t};\n\t}\n\n\t/** The actual function.\n\t*/\n\treturn function distributeEvaluation(args) {\n\t\targs = _checkArgs(args);\n\t\tvar server = args.server,\n\t\t\tmh = args.mh,\n\t\t\tproblem = mh.problem;\n\t\t/** If the metaheuristic has not been initialized with the problem, do so.\n\t\t*/\n\t\tif (!problem) {\n\t\t\tproblem = args.problemBuilder.apply(null, args.problemDependencies.map(require));\n\t\t\tmh.problem = problem;\n\t\t}\n\n\t\t/** The `problemBuilder` is wrapped in a RequireJS definition and the server is configured\n\t\tto serve it as `problem.js`.\n\t\t*/\n\t\tserver.__serveRequireModule__(args.problemBuilder, 'problem', args.problemDependencies);\n\t\tserver.__serveNodeModule__(inveniemus);\n\n\t\t/** Change the element's `evaluate` method to schedule tasks in the Capataz server.\n\t\t*/\n\t\tproblem.Element.prototype.evaluate = evaluateFunction(args);\n\n\t\t/** Log when every step finishes.\n\t\t*/\n\t\tmh.events.on('advanced', function () {\n\t\t\tvar evalStat = mh.statistics.stat({ key:'evaluation', step: mh.step }),\n\t\t\t\tbest = mh.state[0];\n\t\t\tserver.logger.info(\"Advanced to step #\"+ mh.step +\". Evaluations \"+ evalStat.minimum() +\n\t\t\t\t\" < \"+ evalStat.average() +\" < \"+ evalStat.maximum() +\" (stddev: \"+\n\t\t\t\tevalStat.standardDeviation() +\").\");\n\t\t\tserver.logger.info(\"\\tBest so far: \"+ best.emblem() +\".\");\n\t\t});\n\n\t\t/** Set the server to stop when the run finishes.\n\t\t*/\n\t\tvar keepRunning = !!args.keepRunning;\n\t\tfunction end() {\n\t\t\tif (!keepRunning) {\n\t\t\t\tserver.logger.info(\"Stopping server.\");\n\t\t\t\tsetTimeout(process.exit, 10);\n\t\t\t}\n\t\t\treturn mh;\n\t\t}\n\t\treturn mh.run().then(function () {\n\t\t\tserver.logger.info(\"Finished.\");\n\t\t\treturn end();\n\t\t}, function (error) {\n\t\t\tserver.logger.error(error +'');\n\t\t\treturn end();\n\t\t});\n\t};\n})(); // distributeEvaluation()\n"]}